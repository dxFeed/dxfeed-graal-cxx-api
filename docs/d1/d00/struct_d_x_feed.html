<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>dxFeed Graal CXX API: DXFeed Struct Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">dxFeed Graal CXX API<span id="projectnumber">&#160;v4.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d1/d00/struct_d_x_feed.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="../../d3/d03/struct_d_x_feed-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">DXFeed Struct Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Main entry class for dxFeed API (<b>read it first</b>).  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d7/d02/_d_x_feed_8hpp_source.html">DXFeed.hpp</a>&gt;</code></p>
<div id="dynsection-0" onclick="return dynsection.toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="../../closed.png" alt="+"/> Inheritance diagram for DXFeed:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="../../d1/d00/struct_d_x_feed.png" usemap="#DXFeed_map" alt=""/>
  <map id="DXFeed_map" name="DXFeed_map">
<area href="../../df/d01/struct_shared_entity.html" title="Base abstract &quot;shared entity&quot; class. Has some helpers for dynamic polymorphism." alt="SharedEntity" shape="rect" coords="0,56,84,80"/>
<area href="../../dc/d00/struct_entity.html" title="Base abstract class for all dxFeed C++ API entities." alt="Entity" shape="rect" coords="0,0,84,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ada114928a7e5c6119e41ad6d07cda533" id="r_ada114928a7e5c6119e41ad6d07cda533"><td class="memItemLeft" align="right" valign="top"><a id="ada114928a7e5c6119e41ad6d07cda533" name="ada114928a7e5c6119e41ad6d07cda533"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Ptr</b> = std::shared_ptr&lt;<a class="el" href="../../d1/d00/struct_d_x_feed.html">DXFeed</a>&gt;</td></tr>
<tr class="memdesc:ada114928a7e5c6119e41ad6d07cda533"><td class="mdescLeft">&#160;</td><td class="mdescRight">The alias to a type of shared pointer to the <a class="el" href="../../d1/d00/struct_d_x_feed.html" title="Main entry class for dxFeed API (read it first).">DXFeed</a> object. <br /></td></tr>
<tr class="separator:ada114928a7e5c6119e41ad6d07cda533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c7eedb4ed6ef2785fc5ac9915bf478f" id="r_a5c7eedb4ed6ef2785fc5ac9915bf478f"><td class="memItemLeft" align="right" valign="top"><a id="a5c7eedb4ed6ef2785fc5ac9915bf478f" name="a5c7eedb4ed6ef2785fc5ac9915bf478f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Unique</b> = std::unique_ptr&lt;<a class="el" href="../../d1/d00/struct_d_x_feed.html">DXFeed</a>&gt;</td></tr>
<tr class="memdesc:a5c7eedb4ed6ef2785fc5ac9915bf478f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The alias to a type of unique pointer to the <a class="el" href="../../d1/d00/struct_d_x_feed.html" title="Main entry class for dxFeed API (read it first).">DXFeed</a> object. <br /></td></tr>
<tr class="separator:a5c7eedb4ed6ef2785fc5ac9915bf478f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_struct_shared_entity"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_types_struct_shared_entity')"><img src="../../closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="../../df/d01/struct_shared_entity.html">SharedEntity</a></td></tr>
<tr class="memitem:ab7cfbb67329faf3203faea77a9a00e16 inherit pub_types_struct_shared_entity" id="r_ab7cfbb67329faf3203faea77a9a00e16"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>Ptr</b> = std::shared_ptr&lt;<a class="el" href="../../df/d01/struct_shared_entity.html">SharedEntity</a>&gt;</td></tr>
<tr class="memdesc:ab7cfbb67329faf3203faea77a9a00e16 inherit pub_types_struct_shared_entity"><td class="mdescLeft">&#160;</td><td class="mdescRight">The alias to a type of shared pointer to the <a class="el" href="../../df/d01/struct_shared_entity.html" title="Base abstract &quot;shared entity&quot; class. Has some helpers for dynamic polymorphism.">SharedEntity</a> object. <br /></td></tr>
<tr class="separator:ab7cfbb67329faf3203faea77a9a00e16 inherit pub_types_struct_shared_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4ff4c7ffd9d21557e71f657da4cc3e6c" id="r_a4ff4c7ffd9d21557e71f657da4cc3e6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ff4c7ffd9d21557e71f657da4cc3e6c">attachSubscription</a> (std::shared_ptr&lt; <a class="el" href="../../dc/d00/class_d_x_feed_subscription.html">DXFeedSubscription</a> &gt; subscription)</td></tr>
<tr class="memdesc:a4ff4c7ffd9d21557e71f657da4cc3e6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches the given subscription to this feed.  <br /></td></tr>
<tr class="separator:a4ff4c7ffd9d21557e71f657da4cc3e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa942979b75cb8dd6e7694ad25ed0d31e" id="r_aa942979b75cb8dd6e7694ad25ed0d31e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa942979b75cb8dd6e7694ad25ed0d31e">detachSubscription</a> (std::shared_ptr&lt; <a class="el" href="../../dc/d00/class_d_x_feed_subscription.html">DXFeedSubscription</a> &gt; subscription)</td></tr>
<tr class="memdesc:aa942979b75cb8dd6e7694ad25ed0d31e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detaches the given subscription from this feed.  <br /></td></tr>
<tr class="separator:aa942979b75cb8dd6e7694ad25ed0d31e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca09f0839d300d541a50fcef811fac9" id="r_a1ca09f0839d300d541a50fcef811fac9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ca09f0839d300d541a50fcef811fac9">detachSubscriptionAndClear</a> (std::shared_ptr&lt; <a class="el" href="../../dc/d00/class_d_x_feed_subscription.html">DXFeedSubscription</a> &gt; subscription)</td></tr>
<tr class="memdesc:a1ca09f0839d300d541a50fcef811fac9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detaches the given subscription from this feed and clears data delivered to this subscription by publishing empty events.  <br /></td></tr>
<tr class="separator:a1ca09f0839d300d541a50fcef811fac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b0320e862240f330c7494237882e20" id="r_ab2b0320e862240f330c7494237882e20"><td class="memTemplParams" colspan="2">template&lt;Derived&lt; <a class="el" href="../../dc/d00/struct_lasting_event.html">LastingEvent</a> &gt; E&gt; </td></tr>
<tr class="memitem:ab2b0320e862240f330c7494237882e20"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; E &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab2b0320e862240f330c7494237882e20">getLastEvent</a> (std::shared_ptr&lt; E &gt; event)</td></tr>
<tr class="memdesc:ab2b0320e862240f330c7494237882e20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last event for the specified event instance.  <br /></td></tr>
<tr class="separator:ab2b0320e862240f330c7494237882e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2072b9b437b4d0e16f1ddfab378404d" id="r_af2072b9b437b4d0e16f1ddfab378404d"><td class="memTemplParams" colspan="2">template&lt;typename Collection , typename Element  = std::decay_t&lt;decltype(std::begin(Collection()))&gt;, typename Event  = std::decay_t&lt;decltype(*Element())&gt;&gt; </td></tr>
<tr class="memitem:af2072b9b437b4d0e16f1ddfab378404d"><td class="memTemplItemLeft" align="right" valign="top">const Collection &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af2072b9b437b4d0e16f1ddfab378404d">getLastEvents</a> (const Collection &amp;events)</td></tr>
<tr class="memdesc:af2072b9b437b4d0e16f1ddfab378404d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last events for the specified list of event instances.  <br /></td></tr>
<tr class="separator:af2072b9b437b4d0e16f1ddfab378404d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bd971c7b4d1334f052e19c6a622a6e2" id="r_a6bd971c7b4d1334f052e19c6a622a6e2"><td class="memTemplParams" colspan="2">template&lt;Derived&lt; <a class="el" href="../../dc/d00/struct_lasting_event.html">LastingEvent</a> &gt; E&gt; </td></tr>
<tr class="memitem:a6bd971c7b4d1334f052e19c6a622a6e2"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; E &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6bd971c7b4d1334f052e19c6a622a6e2">getLastEventIfSubscribed</a> (const <a class="el" href="../../d1/d01/struct_symbol_wrapper.html">SymbolWrapper</a> &amp;symbol)</td></tr>
<tr class="memdesc:a6bd971c7b4d1334f052e19c6a622a6e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last event for the specified event type and symbol if there is a subscription for it.  <br /></td></tr>
<tr class="separator:a6bd971c7b4d1334f052e19c6a622a6e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b65557ce6df1ad62e34829361038306" id="r_a7b65557ce6df1ad62e34829361038306"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="../../dc/d00/class_d_x_feed_subscription.html">DXFeedSubscription</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b65557ce6df1ad62e34829361038306">createSubscription</a> (const <a class="el" href="../../d3/d01/class_event_type_enum.html">EventTypeEnum</a> &amp;eventType)</td></tr>
<tr class="memdesc:a7b65557ce6df1ad62e34829361038306"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates new subscription for a single event type that is <em>attached</em> to this feed.  <br /></td></tr>
<tr class="separator:a7b65557ce6df1ad62e34829361038306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2278d6f68eb245e7631e25c41f02e493" id="r_a2278d6f68eb245e7631e25c41f02e493"><td class="memTemplParams" colspan="2">template&lt;typename EventTypeIt &gt; </td></tr>
<tr class="memitem:a2278d6f68eb245e7631e25c41f02e493"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="../../dc/d00/class_d_x_feed_subscription.html">DXFeedSubscription</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2278d6f68eb245e7631e25c41f02e493">createSubscription</a> (EventTypeIt begin, EventTypeIt end)</td></tr>
<tr class="memdesc:a2278d6f68eb245e7631e25c41f02e493"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates new subscription for multiple event types that is <em>attached</em> to this feed.  <br /></td></tr>
<tr class="separator:a2278d6f68eb245e7631e25c41f02e493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1550a58d5f2ad3ae2a68c9448c869259" id="r_a1550a58d5f2ad3ae2a68c9448c869259"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="../../dc/d00/class_d_x_feed_subscription.html">DXFeedSubscription</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1550a58d5f2ad3ae2a68c9448c869259">createSubscription</a> (std::initializer_list&lt; <a class="el" href="../../d3/d01/class_event_type_enum.html">EventTypeEnum</a> &gt; eventTypes)</td></tr>
<tr class="memdesc:a1550a58d5f2ad3ae2a68c9448c869259"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates new subscription for multiple event types that is <em>attached</em> to this feed.  <br /></td></tr>
<tr class="separator:a1550a58d5f2ad3ae2a68c9448c869259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73de81bd22cdf0a2255cd8030a0a9d48" id="r_a73de81bd22cdf0a2255cd8030a0a9d48"><td class="memTemplParams" colspan="2">template&lt;typename EventTypesCollection &gt; </td></tr>
<tr class="memitem:a73de81bd22cdf0a2255cd8030a0a9d48"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="../../dc/d00/class_d_x_feed_subscription.html">DXFeedSubscription</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a73de81bd22cdf0a2255cd8030a0a9d48">createSubscription</a> (EventTypesCollection &amp;&amp;eventTypes)</td></tr>
<tr class="memdesc:a73de81bd22cdf0a2255cd8030a0a9d48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates new subscription for multiple event types that is <em>attached</em> to this feed.  <br /></td></tr>
<tr class="separator:a73de81bd22cdf0a2255cd8030a0a9d48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac055a7b46d8ba6cb0cf9a3ffb7c99187" id="r_ac055a7b46d8ba6cb0cf9a3ffb7c99187"><td class="memTemplParams" colspan="2">template&lt;Derived&lt; <a class="el" href="../../dc/d00/struct_lasting_event.html">LastingEvent</a> &gt; E&gt; </td></tr>
<tr class="memitem:ac055a7b46d8ba6cb0cf9a3ffb7c99187"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="../../d5/d00/struct_promise.html">Promise</a>&lt; std::shared_ptr&lt; E &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac055a7b46d8ba6cb0cf9a3ffb7c99187">getLastEventPromise</a> (const <a class="el" href="../../d1/d01/struct_symbol_wrapper.html">SymbolWrapper</a> &amp;symbol) const</td></tr>
<tr class="memdesc:ac055a7b46d8ba6cb0cf9a3ffb7c99187"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests the last event for the specified event type and symbol.  <br /></td></tr>
<tr class="separator:ac055a7b46d8ba6cb0cf9a3ffb7c99187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8349413be98d0cbf4fa2fde291b17da" id="r_ab8349413be98d0cbf4fa2fde291b17da"><td class="memTemplParams" colspan="2">template&lt;Derived&lt; <a class="el" href="../../dc/d00/struct_lasting_event.html">LastingEvent</a> &gt; E, typename SymbolIt &gt; </td></tr>
<tr class="memitem:ab8349413be98d0cbf4fa2fde291b17da"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="../../dd/d00/struct_promise_list.html">PromiseList</a>&lt; E &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab8349413be98d0cbf4fa2fde291b17da">getLastEventsPromises</a> (SymbolIt begin, SymbolIt end) const</td></tr>
<tr class="memdesc:ab8349413be98d0cbf4fa2fde291b17da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests the last events for the specified event type and a collection of symbols.  <br /></td></tr>
<tr class="separator:ab8349413be98d0cbf4fa2fde291b17da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d1221d5316f92a42744fe619df4130c" id="r_a6d1221d5316f92a42744fe619df4130c"><td class="memTemplParams" colspan="2">template&lt;Derived&lt; <a class="el" href="../../dc/d00/struct_lasting_event.html">LastingEvent</a> &gt; E, <a class="el" href="../../d0/d03/concept_convertible_to_symbol_wrapper_collection.html">ConvertibleToSymbolWrapperCollection</a> SymbolsCollection&gt; </td></tr>
<tr class="memitem:a6d1221d5316f92a42744fe619df4130c"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="../../dd/d00/struct_promise_list.html">PromiseList</a>&lt; E &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6d1221d5316f92a42744fe619df4130c">getLastEventsPromises</a> (SymbolsCollection &amp;&amp;collection) const</td></tr>
<tr class="memdesc:a6d1221d5316f92a42744fe619df4130c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests the last events for the specified event type and a collection of symbols.  <br /></td></tr>
<tr class="separator:a6d1221d5316f92a42744fe619df4130c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3870f7a75b2202f707710a0fe03e79c0" id="r_a3870f7a75b2202f707710a0fe03e79c0"><td class="memTemplParams" colspan="2">template&lt;Derived&lt; <a class="el" href="../../dc/d00/struct_lasting_event.html">LastingEvent</a> &gt; E&gt; </td></tr>
<tr class="memitem:a3870f7a75b2202f707710a0fe03e79c0"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="../../dd/d00/struct_promise_list.html">PromiseList</a>&lt; E &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3870f7a75b2202f707710a0fe03e79c0">getLastEventsPromises</a> (std::initializer_list&lt; <a class="el" href="../../d1/d01/struct_symbol_wrapper.html">SymbolWrapper</a> &gt; collection) const</td></tr>
<tr class="memdesc:a3870f7a75b2202f707710a0fe03e79c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests the last events for the specified event type and a collection of symbols.  <br /></td></tr>
<tr class="separator:a3870f7a75b2202f707710a0fe03e79c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf8c505c647ad5aa1e1341d8cdef5850" id="r_adf8c505c647ad5aa1e1341d8cdef5850"><td class="memTemplParams" colspan="2">template&lt;Derived&lt; <a class="el" href="../../da/d02/struct_indexed_event.html">IndexedEvent</a> &gt; E&gt; </td></tr>
<tr class="memitem:adf8c505c647ad5aa1e1341d8cdef5850"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="../../d5/d00/struct_promise.html">Promise</a>&lt; std::vector&lt; std::shared_ptr&lt; E &gt; &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adf8c505c647ad5aa1e1341d8cdef5850">getIndexedEventsPromise</a> (const <a class="el" href="../../d1/d01/struct_symbol_wrapper.html">SymbolWrapper</a> &amp;symbol, const <a class="el" href="../../d7/d03/class_indexed_event_source.html">IndexedEventSource</a> &amp;source) const</td></tr>
<tr class="memdesc:adf8c505c647ad5aa1e1341d8cdef5850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests a container of indexed events for the specified event type, symbol, and source.  <br /></td></tr>
<tr class="separator:adf8c505c647ad5aa1e1341d8cdef5850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a531ffc7dd7616d22b35f69ec7feebd5a" id="r_a531ffc7dd7616d22b35f69ec7feebd5a"><td class="memTemplParams" colspan="2">template&lt;Derived&lt; <a class="el" href="../../da/d03/struct_time_series_event.html">TimeSeriesEvent</a> &gt; E&gt; </td></tr>
<tr class="memitem:a531ffc7dd7616d22b35f69ec7feebd5a"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="../../d5/d00/struct_promise.html">Promise</a>&lt; std::vector&lt; std::shared_ptr&lt; E &gt; &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a531ffc7dd7616d22b35f69ec7feebd5a">getTimeSeriesPromise</a> (const <a class="el" href="../../d1/d01/struct_symbol_wrapper.html">SymbolWrapper</a> &amp;symbol, std::int64_t fromTime, std::int64_t toTime) const</td></tr>
<tr class="memdesc:a531ffc7dd7616d22b35f69ec7feebd5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests time series of events for the specified event type, symbol, and a range of time.  <br /></td></tr>
<tr class="separator:a531ffc7dd7616d22b35f69ec7feebd5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad32672c2b620909071feb3e1727ff7db" id="r_ad32672c2b620909071feb3e1727ff7db"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad32672c2b620909071feb3e1727ff7db">toString</a> () const override</td></tr>
<tr class="memdesc:ad32672c2b620909071feb3e1727ff7db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string representation of the current object.  <br /></td></tr>
<tr class="separator:ad32672c2b620909071feb3e1727ff7db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_struct_shared_entity"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_struct_shared_entity')"><img src="../../closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="../../df/d01/struct_shared_entity.html">SharedEntity</a></td></tr>
<tr class="memitem:ae774e293e95fbf8ebb4d22f714e80272 inherit pub_methods_struct_shared_entity" id="r_ae774e293e95fbf8ebb4d22f714e80272"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae774e293e95fbf8ebb4d22f714e80272 inherit pub_methods_struct_shared_entity"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../df/d01/struct_shared_entity.html#ae774e293e95fbf8ebb4d22f714e80272">is</a> () const noexcept</td></tr>
<tr class="memdesc:ae774e293e95fbf8ebb4d22f714e80272 inherit pub_methods_struct_shared_entity"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that pointer to the current type could be converted to type T* In other words: whether type T belongs to the type hierarchy in which the current type resides.  <br /></td></tr>
<tr class="separator:ae774e293e95fbf8ebb4d22f714e80272 inherit pub_methods_struct_shared_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c4521da539591dee08051ba77a10a8 inherit pub_methods_struct_shared_entity" id="r_a95c4521da539591dee08051ba77a10a8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a95c4521da539591dee08051ba77a10a8 inherit pub_methods_struct_shared_entity"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../df/d01/struct_shared_entity.html#a95c4521da539591dee08051ba77a10a8">sharedAs</a> () noexcept</td></tr>
<tr class="memdesc:a95c4521da539591dee08051ba77a10a8 inherit pub_methods_struct_shared_entity"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the current object wrapped in a smart pointer to type T.  <br /></td></tr>
<tr class="separator:a95c4521da539591dee08051ba77a10a8 inherit pub_methods_struct_shared_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a348c971deaca898a477262e5bd190d03 inherit pub_methods_struct_shared_entity" id="r_a348c971deaca898a477262e5bd190d03"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a348c971deaca898a477262e5bd190d03 inherit pub_methods_struct_shared_entity"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../df/d01/struct_shared_entity.html#a348c971deaca898a477262e5bd190d03">sharedAs</a> () const noexcept</td></tr>
<tr class="memdesc:a348c971deaca898a477262e5bd190d03 inherit pub_methods_struct_shared_entity"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the current object wrapped in a smart pointer to type T.  <br /></td></tr>
<tr class="separator:a348c971deaca898a477262e5bd190d03 inherit pub_methods_struct_shared_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_struct_entity"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_struct_entity')"><img src="../../closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="../../dc/d00/struct_entity.html">Entity</a></td></tr>
<tr class="memitem:a1a32f1338075f0ccd3ab743058f641de inherit pub_methods_struct_entity" id="r_a1a32f1338075f0ccd3ab743058f641de"><td class="memItemLeft" align="right" valign="top">
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~Entity</b> () noexcept=default</td></tr>
<tr class="memdesc:a1a32f1338075f0ccd3ab743058f641de inherit pub_methods_struct_entity"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default virtual d-tor. <br /></td></tr>
<tr class="separator:a1a32f1338075f0ccd3ab743058f641de inherit pub_methods_struct_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a9da30940a4c663a9b9a293d0692f240c" id="r_a9da30940a4c663a9b9a293d0692f240c"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="../../d1/d00/struct_d_x_feed.html">DXFeed</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9da30940a4c663a9b9a293d0692f240c">getInstance</a> ()</td></tr>
<tr class="memdesc:a9da30940a4c663a9b9a293d0692f240c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a default application-wide singleton instance of feed.  <br /></td></tr>
<tr class="separator:a9da30940a4c663a9b9a293d0692f240c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a99ca9e3a2966be589876135ed3d833a7" id="r_a99ca9e3a2966be589876135ed3d833a7"><td class="memItemLeft" align="right" valign="top"><a id="a99ca9e3a2966be589876135ed3d833a7" name="a99ca9e3a2966be589876135ed3d833a7"></a>
struct&#160;</td><td class="memItemRight" valign="bottom"><b>DXEndpoint</b></td></tr>
<tr class="separator:a99ca9e3a2966be589876135ed3d833a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Main entry class for dxFeed API (<b>read it first</b>). </p>
<h3>Sample usage</h3>
<p>This section gives sample usage scenarios.</p>
<h4>Default singleton instance</h4>
<p>There is a singleton instance of the feed that is returned by <a class="el" href="#a9da30940a4c663a9b9a293d0692f240c" title="Returns a default application-wide singleton instance of feed.">DXFeed::getInstance()</a> method. It is created on the first use with default configuration properties that are explained in detail in documentation for <a class="el" href="../../d9/d00/struct_d_x_endpoint.html" title="Manages network connections to feed or publisher.">DXEndpoint</a> class in the "Default properties" section.</p>
<p>In particular, you can provide a default address to connect and credentials using "@ref DXEndpoint::DXFEED_ADDRESS_PROPERTY "dxfeed.address"", "@ref DXEndpoint::DXFEED_USER_PROPERTY "dxfeed.user"", and "@ref DXEndpoint::DXFEED_PASSWORD_PROPERTY "dxfeed.password"" system properties or by putting them into "@ref DXEndpoint::DXFEED_PROPERTIES_PROPERTY "dxfeed.properties"" file in the same directory. dxFeed API samples come with a ready-to-use "&lt;b&gt;dxfeed.properties&lt;/b&gt;" file that contains an address of dxFeed demo feed at "&lt;b&gt;demo.dxfeed.com:7300&lt;/b&gt;" and demo access credentials.</p>
<h4>Subscribe for single event type</h4>
<p>The following code creates listener that prints mid price for each quote and subscribes for quotes on SPDR S&amp;P 500 ETF symbol: </p><pre><code>
auto sub = <a class="el" href="../../d1/d00/struct_d_x_feed.html">DXFeed</a>::<a class="el" href="#a9da30940a4c663a9b9a293d0692f240c">getInstance</a>()-&gt;<a class="el" href="#a7b65557ce6df1ad62e34829361038306">createSubscription</a>(<a class="el" href="../../de/d03/class_quote.html#a21144621df5bd59e2a342592bd501d0e" title="Type identifier and additional information about the current event class.">Quote::TYPE</a>);

sub-&gt;<a class="el" href="../../dc/d00/class_d_x_feed_subscription.html#ab0990b7f3aca1000d3d414c57b7e4c69">addEventListener</a>&lt;Quote&gt;([](const auto&amp; quotes) {
    for (const auto&amp; quote : quotes) {
        std::cout &lt;&lt; "Mid = " + (quote-&gt;<a class="el" href="../../de/d03/class_quote.html#a55ac60689157fcb1cdc4540c15324a43">getBidPrice</a>() + quote-&gt;<a class="el" href="../../de/d03/class_quote.html#af5e7f5da9d7414d7281242d72c272ea5">getAskPrice</a>()) / 2) &lt;&lt; std::endl;
    }
});

sub-&gt;<a class="el" href="../../dc/d00/class_d_x_feed_subscription.html#af18678401376bd1985bdac924b967aa6">addSymbols</a>("SPY");</code></pre><p>Note, that order of calls is important here. By attaching listeners first and then setting subscription we ensure that the current quote gets received by the listener. See <a class="el" href="../../dc/d00/class_d_x_feed_subscription.html#af18678401376bd1985bdac924b967aa6" title="Adds the specified symbol to the set of subscribed symbols.">DXFeedSubscription::addSymbols()</a> for details. If a set of symbols is changed first, then <a class="el" href="../../dc/d00/class_d_x_feed_subscription.html#ab0990b7f3aca1000d3d414c57b7e4c69">sub-&gt;addEventListener</a> raises an IllegalStateException in JVM to protected from hard-to-catch bugs with potentially missed events.</p>
<h4>Subscribe for multiple event types</h4>
<p>The following code creates listener that prints each received event and subscribes for quotes and trades on SPDR S&amp;P 500 ETF symbol: </p><pre><code>
auto sub = <a class="el" href="../../d1/d00/struct_d_x_feed.html">DXFeed</a>::<a class="el" href="#a9da30940a4c663a9b9a293d0692f240c">getInstance</a>()-&gt;<a class="el" href="#a7b65557ce6df1ad62e34829361038306">createSubscription</a>({<a class="el" href="../../de/d03/class_quote.html#a21144621df5bd59e2a342592bd501d0e" title="Type identifier and additional information about the current event class.">Quote::TYPE</a>, <a class="el" href="../../d9/d03/class_trade.html#a2ac80fbec5eff5162e191e7bfc528fc3" title="Type identifier and additional information about the current event class.">Trade::TYPE</a>});

sub-&gt;<a class="el" href="../../dc/d00/class_d_x_feed_subscription.html#ab0990b7f3aca1000d3d414c57b7e4c69">addEventListener</a>([](auto&amp;&amp; events) {
    for (const auto&amp; event : events) {
        std::cout &lt;&lt; event &lt;&lt; std::endl;
    }
});

sub-&gt;<a class="el" href="../../dc/d00/class_d_x_feed_subscription.html#af18678401376bd1985bdac924b967aa6">addSymbols</a>("SPY");</code></pre><h4>Subscribe for event and query periodically its last value</h4>
<p>The following code subscribes for trades on SPDR S&amp;P 500 ETF symbol and prints last trade every second.</p>
<pre><code>
using namespace std::chrono_literals;

auto sub = <a class="el" href="../../d1/d00/struct_d_x_feed.html">DXFeed</a>::<a class="el" href="#a9da30940a4c663a9b9a293d0692f240c">getInstance</a>()-&gt;<a class="el" href="#a7b65557ce6df1ad62e34829361038306">createSubscription</a>({<a class="el" href="../../d9/d03/class_trade.html#a2ac80fbec5eff5162e191e7bfc528fc3" title="Type identifier and additional information about the current event class.">Trade::TYPE</a>});

sub-&gt;<a class="el" href="../../dc/d00/class_d_x_feed_subscription.html#af18678401376bd1985bdac924b967aa6">addSymbols</a>("SPY");

auto feed = <a class="el" href="../../d1/d00/struct_d_x_feed.html">DXFeed</a>::<a class="el" href="#a9da30940a4c663a9b9a293d0692f240c">getInstance</a>();

while (true) {
    std::cout &lt;&lt; System.out.println(feed-&gt;<a class="el" href="#ab2b0320e862240f330c7494237882e20">getLastEvent</a>(Trade::create("SPY")));
    std::this_thread::sleep_for(1000ms);
}</code></pre><h3>Threads and locks</h3>
<p>This class is thread-safe and can be used concurrently from multiple threads without external synchronization. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a4ff4c7ffd9d21557e71f657da4cc3e6c" name="a4ff4c7ffd9d21557e71f657da4cc3e6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ff4c7ffd9d21557e71f657da4cc3e6c">&#9670;&#160;</a></span>attachSubscription()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DXFeed::attachSubscription </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../dc/d00/class_d_x_feed_subscription.html">DXFeedSubscription</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>subscription</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attaches the given subscription to this feed. </p>
<p>This method does nothing if the corresponding subscription is already attached to this feed.</p>
<p>This feed publishes data to the attached subscription. Application can attach event listener via <a class="el" href="../../dc/d00/class_d_x_feed_subscription.html#ab0990b7f3aca1000d3d414c57b7e4c69" title="Adds listener for events.">DXFeedSubscription::addEventListener</a> to get notified about data changes and can change its data subscription via <a class="el" href="../../dc/d00/class_d_x_feed_subscription.html" title="Subscription for a set of symbols and event types.">DXFeedSubscription</a> methods.</p>
<h3>Implementation notes</h3>
<p>This method adds a non-serializable ObservableSubscriptionChangeListener for the given subscription via <a class="el" href="../../dc/d00/class_d_x_feed_subscription.html#a169831b3651571a2f49d04a56dba67fb" title="Adds subscription change listener.">DXFeedSubscription::addChangeListener</a> method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subscription</td><td>The subscription. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dc/d00/class_d_x_feed_subscription.html" title="Subscription for a set of symbols and event types.">DXFeedSubscription</a> </dd></dl>

</div>
</div>
<a id="a7b65557ce6df1ad62e34829361038306" name="a7b65557ce6df1ad62e34829361038306"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b65557ce6df1ad62e34829361038306">&#9670;&#160;</a></span>createSubscription() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="../../dc/d00/class_d_x_feed_subscription.html">DXFeedSubscription</a> &gt; DXFeed::createSubscription </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d01/class_event_type_enum.html">EventTypeEnum</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>eventType</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates new subscription for a single event type that is <em>attached</em> to this feed. </p>
<p>This method creates new <a class="el" href="../../dc/d00/class_d_x_feed_subscription.html" title="Subscription for a set of symbols and event types.">DXFeedSubscription</a> and invokes <a class="el" href="">Example: {cpp} auto sub = dxfcpp::DXFeed::getInstance()-&gt;createSubscription(dxfcpp::Quote::TYPE);   eventType The type of event  The new subscription </a></p>

</div>
</div>
<a id="a2278d6f68eb245e7631e25c41f02e493" name="a2278d6f68eb245e7631e25c41f02e493"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2278d6f68eb245e7631e25c41f02e493">&#9670;&#160;</a></span>createSubscription() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EventTypeIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="../../dc/d00/class_d_x_feed_subscription.html">DXFeedSubscription</a> &gt; DXFeed::createSubscription </td>
          <td>(</td>
          <td class="paramtype">EventTypeIt</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EventTypeIt</td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates new subscription for multiple event types that is <em>attached</em> to this feed. </p>
<p>This method creates new <a class="el" href="../../dc/d00/class_d_x_feed_subscription.html" title="Subscription for a set of symbols and event types.">DXFeedSubscription</a> and invokes <a class="el" href="">Example: {cpp} auto eventTypes = {dxfcpp::Quote::TYPE, dxfcpp::TimeAndSale::TYPE};  auto sub = dxfcpp::DXFeed::getInstance()-&gt;createSubscription(eventTypes.begin(), eventTypes.end());   {cpp} std::vector types{dxfcpp::Quote::TYPE, dxfcpp::Trade::TYPE, dxfcpp::Summary::TYPE};  auto sub = dxfcpp::DXFeedSubscription::create(types.begin(), types.end());   {cpp} std::set types{dxfcpp::Quote::TYPE, dxfcpp::Trade::TYPE, dxfcpp::Summary::TYPE}; auto endpoint = dxfcpp::DXEndpoint::newBuilder()-&gt;withRole(dxfcpp::DXEndpoint::Role::FEED)-&gt;build(); auto sub = endpoint-&gt;getFeed()-&gt;createSubscription(eventTypes.begin(), eventTypes.end());  endpoint-&gt;connect("demo.dxfeed.com:7300");    EventTypeIt The iterator type of the collection of event types  begin The start iterator  end The end iterator  The new subscription </a></p>

</div>
</div>
<a id="a73de81bd22cdf0a2255cd8030a0a9d48" name="a73de81bd22cdf0a2255cd8030a0a9d48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73de81bd22cdf0a2255cd8030a0a9d48">&#9670;&#160;</a></span>createSubscription() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EventTypesCollection &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="../../dc/d00/class_d_x_feed_subscription.html">DXFeedSubscription</a> &gt; DXFeed::createSubscription </td>
          <td>(</td>
          <td class="paramtype">EventTypesCollection &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>eventTypes</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates new subscription for multiple event types that is <em>attached</em> to this feed. </p>
<p>This method creates new <a class="el" href="../../dc/d00/class_d_x_feed_subscription.html" title="Subscription for a set of symbols and event types.">DXFeedSubscription</a> and invokes <a class="el" href="">Example: {cpp} auto sub = dxfcpp::DXFeed::getInstance()-&gt;createSubscription(std::unordered_set{dxfcpp::Quote::TYPE, dxfcpp::TimeAndSale::TYPE});   {cpp} std::vector types = {dxfcpp::Quote::TYPE, dxfcpp::TimeAndSale::TYPE}; auto sub = dxfcpp::DXFeed::getInstance()-&gt;createSubscription(types);    EventTypesCollection The class of the collection of event types  eventTypes The collection of event types  The new subscription </a></p>

</div>
</div>
<a id="a1550a58d5f2ad3ae2a68c9448c869259" name="a1550a58d5f2ad3ae2a68c9448c869259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1550a58d5f2ad3ae2a68c9448c869259">&#9670;&#160;</a></span>createSubscription() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="../../dc/d00/class_d_x_feed_subscription.html">DXFeedSubscription</a> &gt; DXFeed::createSubscription </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="../../d3/d01/class_event_type_enum.html">EventTypeEnum</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>eventTypes</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates new subscription for multiple event types that is <em>attached</em> to this feed. </p>
<p>This method creates new <a class="el" href="../../dc/d00/class_d_x_feed_subscription.html" title="Subscription for a set of symbols and event types.">DXFeedSubscription</a> and invokes <a class="el" href="">Example: {cpp} auto sub = dxfcpp::DXFeed::getInstance()-&gt;createSubscription({dxfcpp::Quote::TYPE, dxfcpp::TimeAndSale::TYPE});   eventTypes The initializer list of event types  The new subscription </a></p>

</div>
</div>
<a id="aa942979b75cb8dd6e7694ad25ed0d31e" name="aa942979b75cb8dd6e7694ad25ed0d31e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa942979b75cb8dd6e7694ad25ed0d31e">&#9670;&#160;</a></span>detachSubscription()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DXFeed::detachSubscription </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../dc/d00/class_d_x_feed_subscription.html">DXFeedSubscription</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>subscription</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detaches the given subscription from this feed. </p>
<p>This method does nothing if the corresponding subscription is not attached to this feed.</p>
<h3>Implementation notes</h3>
<p>This method removes ObservableSubscriptionChangeListener from the given subscription via <a class="el" href="../../dc/d00/class_d_x_feed_subscription.html#ad9b402b35d271eb197c3e3b03030fed4" title="Removes subscription change listener by id.">DXFeedSubscription::removeChangeListener</a> method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subscription</td><td>The subscription. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dc/d00/class_d_x_feed_subscription.html" title="Subscription for a set of symbols and event types.">DXFeedSubscription</a> </dd></dl>

</div>
</div>
<a id="a1ca09f0839d300d541a50fcef811fac9" name="a1ca09f0839d300d541a50fcef811fac9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ca09f0839d300d541a50fcef811fac9">&#9670;&#160;</a></span>detachSubscriptionAndClear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DXFeed::detachSubscriptionAndClear </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../dc/d00/class_d_x_feed_subscription.html">DXFeedSubscription</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>subscription</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detaches the given subscription from this feed and clears data delivered to this subscription by publishing empty events. </p>
<p>This method does nothing if the corresponding subscription is not attached to this feed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subscription</td><td>The subscription. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#aa942979b75cb8dd6e7694ad25ed0d31e" title="Detaches the given subscription from this feed.">DXFeed::detachSubscription()</a> </dd></dl>

</div>
</div>
<a id="adf8c505c647ad5aa1e1341d8cdef5850" name="adf8c505c647ad5aa1e1341d8cdef5850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf8c505c647ad5aa1e1341d8cdef5850">&#9670;&#160;</a></span>getIndexedEventsPromise()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Derived&lt; <a class="el" href="../../da/d02/struct_indexed_event.html">IndexedEvent</a> &gt; E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="../../d5/d00/struct_promise.html">Promise</a>&lt; std::vector&lt; std::shared_ptr&lt; E &gt; &gt; &gt; &gt; DXFeed::getIndexedEventsPromise </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/d01/struct_symbol_wrapper.html">SymbolWrapper</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>symbol</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d03/class_indexed_event_source.html">IndexedEventSource</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Requests a container of indexed events for the specified event type, symbol, and source. </p>
<p>This method works only for event types that implement <a class="el" href="../../da/d02/struct_indexed_event.html" title="Represents an indexed collection of up-to-date information about some condition or state of an extern...">IndexedEvent</a> "interface". This method requests the data from the uplink data provider, creates a container of events of the specified <code>eventType</code>, and completes the resulting promise with this container. The events are ordered by <a class="el" href="../../da/d02/struct_indexed_event.html#a4310a26785d5142efba9d7c0094125bc">index</a> in the container.</p>
<p>This method is designed for retrieval of a snapshot only. Use IndexedEventModel if you need a container of indexed events that updates in real time.</p>
<p>The promise is cancelled when the underlying <a class="el" href="../../d9/d00/struct_d_x_endpoint.html" title="Manages network connections to feed or publisher.">DXEndpoint</a> is <a class="el" href="../../d9/d00/struct_d_x_endpoint.html#a70b8f61781bf5991e1c0b77e4a13cb06">closed</a>. If the events are not available for any transient reason (no subscription, no connection to uplink, etc.), then the resulting promise completes when the issue is resolved, which may involve an arbitrarily long wait. Use Promise::await() method to specify timeout while waiting for promise to complete. If the events are permanently not available (not supported), then the promise completes exceptionally with <a class="el" href="../../dd/d01/struct_java_exception.html" title="A wrapper over the interceptable Java exceptions thrown by the dxFeed Native Graal SDK.">JavaException</a> "IllegalArgumentException".</p>
<p>Note, that this method does not work when <a class="el" href="../../d9/d00/struct_d_x_endpoint.html" title="Manages network connections to feed or publisher.">DXEndpoint</a> was created with <a class="el" href="../../d9/d00/struct_d_x_endpoint.html#a4257e04caaa1ff898a60ece339e02810a08e8da2638e7a4a4dfb3d29ab5afb751">STREAM_FEED</a> role (promise completes exceptionally).</p>
<h3>Event source</h3>
<p>Use the <a class="el" href="../../d7/d03/class_indexed_event_source.html#ab359b82d74ee151707106b66eec0a4e3">DEFAULT</a> value for <code>source</code> with events that do not have multiple sources (like <a class="el" href="../../d5/d03/class_series.html" title="Series event is a snapshot of computed values that are available for all option series for a given un...">Series</a>). For events with multiple sources (like <a class="el" href="../../d1/d03/class_order.html" title="Order event is a snapshot for a full available market depth for a symbol.">Order</a>, <a class="el" href="../../da/d03/class_analytic_order.html" title="Represents an extension of Order introducing analytic information, e.g.">AnalyticOrder</a>, <a class="el" href="../../d2/d00/class_otc_markets_order.html" title="Represents an extension of Order for the symbols traded on the OTC Markets.">OtcMarketsOrder</a> and <a class="el" href="../../d7/d03/class_spread_order.html" title="Spread order event is a snapshot for a full available market depth for all spreads on a given underly...">SpreadOrder</a>), use an event-specific source class (for example, <a class="el" href="../../d2/d02/class_order_source.html" title="Identifies source of Order, AnalyticOrder, OtcMarketsOrder and SpreadOrder events.">OrderSource</a>). This method does not support <em>synthetic</em> sources of orders (orders that are automatically generated from <a class="el" href="../../de/d03/class_quote.html" title="Quote event is a snapshot of the best bid and ask prices, and other fields that change with each quot...">Quote</a> events).</p>
<p>This method does not accept an instance of <a class="el" href="../../df/d03/class_indexed_event_subscription_symbol.html" title="Represents subscription to a specific source of indexed events.">IndexedEventSubscriptionSymbol</a> as a <code>symbol</code>. The later class is designed for use with <a class="el" href="../../dc/d00/class_d_x_feed_subscription.html" title="Subscription for a set of symbols and event types.">DXFeedSubscription</a> and to observe source-specific subscription in <a class="el" href="../../da/d00/struct_d_x_publisher.html" title="Provides API for publishing of events to local or remote DXFeed.">DXPublisher</a>.</p>
<h3>Event flags and consistent snapshot</h3>
<p>This method completes promise only when a consistent snapshot of indexed events has been received from the data feed. The <a class="el" href="../../da/d02/struct_indexed_event.html#a5bf54899ccd5dd4bd162ae64fbcc695b">eventFlags</a> property of the events in the resulting list is always zero.</p>
<p>Note, that the resulting list <em>should not</em> be used with <a class="el" href="../../da/d00/struct_d_x_publisher.html#ae6e8cb6b370ea60f1ad5cb80cea2df30" title="Publishes events to the corresponding feed.">DXPublisher::publishEvents()</a> method, because the latter expects events in a different order and with an appropriate flags set. See documentation on a specific event class for details on how they should be published.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">E</td><td>The type of event. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">symbol</td><td>The symbol. </td></tr>
    <tr><td class="paramname">source</td><td>The source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The promise for the result of the request. </dd></dl>

</div>
</div>
<a id="a9da30940a4c663a9b9a293d0692f240c" name="a9da30940a4c663a9b9a293d0692f240c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9da30940a4c663a9b9a293d0692f240c">&#9670;&#160;</a></span>getInstance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DXFCPP_BEGIN_NAMESPACE std::shared_ptr&lt; <a class="el" href="../../d1/d00/struct_d_x_feed.html">DXFeed</a> &gt; DXFeed::getInstance </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a default application-wide singleton instance of feed. </p>
<p>Most applications use only a single data-source and should rely on this method to get one. This is a shortcut to <a class="el" href="../../d9/d00/struct_d_x_endpoint.html">DXEndpoint</a>::<a class="el" href="../../d9/d00/struct_d_x_endpoint.html#a9ee308e31ef33e66ec8b8b83b9cff4de">getInstance()</a>-&gt;<a class="el" href="../../d9/d00/struct_d_x_endpoint.html#a4edad7a8744b1e91873c8c4e2fe244a3">getFeed()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="../../d1/d00/struct_d_x_feed.html" title="Main entry class for dxFeed API (read it first).">DXFeed</a> instance </dd></dl>

</div>
</div>
<a id="ab2b0320e862240f330c7494237882e20" name="ab2b0320e862240f330c7494237882e20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2b0320e862240f330c7494237882e20">&#9670;&#160;</a></span>getLastEvent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Derived&lt; <a class="el" href="../../dc/d00/struct_lasting_event.html">LastingEvent</a> &gt; E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; E &gt; DXFeed::getLastEvent </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; E &gt;</td>          <td class="paramname"><span class="paramname"><em>event</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the last event for the specified event instance. </p>
<p>This method works only for event types that implement <a class="el" href="../../dc/d00/struct_lasting_event.html" title="Represents up-to-date information about some condition or state of an external entity that updates in...">LastingEvent</a> marker interface. This method <b>does not</b> make any remote calls to the uplink data provider. It just retrieves last received event from the local cache of this feed. The events are stored in the cache only if there is some attached <a class="el" href="../../dc/d00/class_d_x_feed_subscription.html" title="Subscription for a set of symbols and event types.">DXFeedSubscription</a> that is subscribed to the corresponding symbol and event type. <a class="el" href="../../d3/d00/struct_wildcard_symbol.html#acf6b6b4eeecdb9cca6e311ed7db387f6" title="Represents [wildcard] subscription to all events of the specific event type.">WildcardSymbol::ALL</a> subscription does not count for that purpose.</p>
<p>Use <a class="el" href="#ac055a7b46d8ba6cb0cf9a3ffb7c99187">getLastEventPromise</a> method if an event needs to be requested in the absence of subscription.</p>
<p>This method fills in the values for the last event into the <code>event argument. If the last event is not available for any reason (no subscription, no connection to uplink, etc.) then the event object is not changed. This method always returns the same</code>event` instance that is passed to it as an argument.</p>
<p>This method provides no way to distinguish a case when there is no subscription from the case when there is a subscription, but the event data have not arrived yet. It is recommended to use <a class="el" href="#a6bd971c7b4d1334f052e19c6a622a6e2">getLastEventIfSubscribed</a> method instead of this <code>getLastEvent</code> method to fail-fast in case when the subscription was supposed to be set by the logic of the code, since <a class="el" href="#a6bd971c7b4d1334f052e19c6a622a6e2">getLastEventIfSubscribed</a> method returns null when there is no subscription.</p>
<p>Note, that this method does not work when <a class="el" href="../../d9/d00/struct_d_x_endpoint.html" title="Manages network connections to feed or publisher.">DXEndpoint</a> was created with <a class="el" href="../../d9/d00/struct_d_x_endpoint.html#a4257e04caaa1ff898a60ece339e02810a08e8da2638e7a4a4dfb3d29ab5afb751">STREAM_FEED</a> role (never fills in the event).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">E</td><td>The type of event. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>The event. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The same event. </dd></dl>

</div>
</div>
<a id="a6bd971c7b4d1334f052e19c6a622a6e2" name="a6bd971c7b4d1334f052e19c6a622a6e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bd971c7b4d1334f052e19c6a622a6e2">&#9670;&#160;</a></span>getLastEventIfSubscribed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Derived&lt; <a class="el" href="../../dc/d00/struct_lasting_event.html">LastingEvent</a> &gt; E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; E &gt; DXFeed::getLastEventIfSubscribed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/d01/struct_symbol_wrapper.html">SymbolWrapper</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>symbol</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the last event for the specified event type and symbol if there is a subscription for it. </p>
<p>This method works only for event types that implement <a class="el" href="../../dc/d00/struct_lasting_event.html" title="Represents up-to-date information about some condition or state of an external entity that updates in...">LastingEvent</a> marker interface. This method <b>does not</b> make any remote calls to the uplink data provider. It just retrieves last received event from the local cache of this feed. The events are stored in the cache only if there is some attached <a class="el" href="../../dc/d00/class_d_x_feed_subscription.html" title="Subscription for a set of symbols and event types.">DXFeedSubscription</a> that is subscribed to the corresponding event type and symbol. The subscription can also be permanently defined using <a class="el" href="../../d9/d00/struct_d_x_endpoint.html" title="Manages network connections to feed or publisher.">DXEndpoint</a> properties. <a class="el" href="../../d3/d00/struct_wildcard_symbol.html#acf6b6b4eeecdb9cca6e311ed7db387f6" title="Represents [wildcard] subscription to all events of the specific event type.">WildcardSymbol::ALL</a> subscription does not count for that purpose. If there is no subscription, then this method returns <code>std::shared_ptr&lt;E&gt;(nullptr)</code>.</p>
<p>If there is a subscription, but the event has not arrived from the uplink data provider, this method returns an non-initialized event object: its eventSymbol property is set to the requested symbol, but all the other properties have their default values.</p>
<p>Use <a class="el" href="#ac055a7b46d8ba6cb0cf9a3ffb7c99187">getLastEventPromise</a> method if an event needs to be requested in the absence of subscription.</p>
<p>Note, that this method does not work when <a class="el" href="../../d9/d00/struct_d_x_endpoint.html" title="Manages network connections to feed or publisher.">DXEndpoint</a>} was created with <a class="el" href="../../d9/d00/struct_d_x_endpoint.html#a4257e04caaa1ff898a60ece339e02810a08e8da2638e7a4a4dfb3d29ab5afb751">STREAM_FEED</a> role (always returns <code>std::shared_ptr&lt;E&gt;(nullptr)</code>).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">E</td><td>The type of event. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">symbol</td><td>The symbol. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the event or <code>std::shared_ptr&lt;E&gt;(nullptr)</code> if there is no subscription for the specified event type and symbol. </dd></dl>

</div>
</div>
<a id="ac055a7b46d8ba6cb0cf9a3ffb7c99187" name="ac055a7b46d8ba6cb0cf9a3ffb7c99187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac055a7b46d8ba6cb0cf9a3ffb7c99187">&#9670;&#160;</a></span>getLastEventPromise()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Derived&lt; <a class="el" href="../../dc/d00/struct_lasting_event.html">LastingEvent</a> &gt; E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="../../d5/d00/struct_promise.html">Promise</a>&lt; std::shared_ptr&lt; E &gt; &gt; &gt; DXFeed::getLastEventPromise </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/d01/struct_symbol_wrapper.html">SymbolWrapper</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>symbol</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Requests the last event for the specified event type and symbol. </p>
<p>This method works only for event types that implement <a class="el" href="../../dc/d00/struct_lasting_event.html" title="Represents up-to-date information about some condition or state of an external entity that updates in...">LastingEvent</a> marker "interface". This method requests the data from the uplink data provider, creates new event of the specified event type, and completes the resulting promise with this event.</p>
<p>The promise is cancelled when the underlying <a class="el" href="../../d9/d00/struct_d_x_endpoint.html" title="Manages network connections to feed or publisher.">DXEndpoint</a> is <a class="el" href="../../d9/d00/struct_d_x_endpoint.html#a70b8f61781bf5991e1c0b77e4a13cb06">closed</a>. If the event is not available for any transient reason (no subscription, no connection to uplink, etc), then the resulting promise completes when the issue is resolved, which may involve an arbitrarily long wait. Use Promise::await() method to specify timeout while waiting for promise to complete. If the event is permanently not available (not supported), then the promise completes exceptionally with <a class="el" href="../../dd/d01/struct_java_exception.html" title="A wrapper over the interceptable Java exceptions thrown by the dxFeed Native Graal SDK.">JavaException</a> "IllegalArgumentException".</p>
<p>There is a bulk version of this method that works much faster for a single event type and multiple symbols. See <a class="el" href="#ab8349413be98d0cbf4fa2fde291b17da" title="Requests the last events for the specified event type and a collection of symbols.">getLastEventsPromises()</a> .</p>
<p>Note, that this method does not work when <a class="el" href="../../d9/d00/struct_d_x_endpoint.html" title="Manages network connections to feed or publisher.">DXEndpoint</a> was created with <a class="el" href="../../d9/d00/struct_d_x_endpoint.html#a4257e04caaa1ff898a60ece339e02810a08e8da2638e7a4a4dfb3d29ab5afb751">STREAM_FEED</a> role (promise completes exceptionally).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">E</td><td>The type of event. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">symbol</td><td>The symbol. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The promise for the result of the request. </dd></dl>

</div>
</div>
<a id="af2072b9b437b4d0e16f1ddfab378404d" name="af2072b9b437b4d0e16f1ddfab378404d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2072b9b437b4d0e16f1ddfab378404d">&#9670;&#160;</a></span>getLastEvents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Collection , typename Element  = std::decay_t&lt;decltype(std::begin(Collection()))&gt;, typename Event  = std::decay_t&lt;decltype(*Element())&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Collection &amp; DXFeed::getLastEvents </td>
          <td>(</td>
          <td class="paramtype">const Collection &amp;</td>          <td class="paramname"><span class="paramname"><em>events</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the last events for the specified list of event instances. </p>
<p>This is a bulk version of <a class="el" href="#ab2b0320e862240f330c7494237882e20">getLastEvent</a> method.</p>
<p>Note, that this method does not work when <a class="el" href="../../d9/d00/struct_d_x_endpoint.html" title="Manages network connections to feed or publisher.">DXEndpoint</a> was created with <a class="el" href="../../d9/d00/struct_d_x_endpoint.html#a4257e04caaa1ff898a60ece339e02810a08e8da2638e7a4a4dfb3d29ab5afb751">STREAM_FEED</a> role.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Collection</td><td>The collection type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">events</td><td>The collection of shared ptrs of events. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The same collection of shared ptrs of events. </dd></dl>

</div>
</div>
<a id="a3870f7a75b2202f707710a0fe03e79c0" name="a3870f7a75b2202f707710a0fe03e79c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3870f7a75b2202f707710a0fe03e79c0">&#9670;&#160;</a></span>getLastEventsPromises() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Derived&lt; <a class="el" href="../../dc/d00/struct_lasting_event.html">LastingEvent</a> &gt; E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="../../dd/d00/struct_promise_list.html">PromiseList</a>&lt; E &gt; &gt; DXFeed::getLastEventsPromises </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="../../d1/d01/struct_symbol_wrapper.html">SymbolWrapper</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>collection</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Requests the last events for the specified event type and a collection of symbols. </p>
<p>This method works only for event types that implement <a class="el" href="../../dc/d00/struct_lasting_event.html" title="Represents up-to-date information about some condition or state of an external entity that updates in...">LastingEvent</a> marker "interface". This method requests the data from the the uplink data provider, creates new events of the specified evet type, and completes the resulting promises with these events.</p>
<p>This is a bulk version of <a class="el" href="#ac055a7b46d8ba6cb0cf9a3ffb7c99187" title="Requests the last event for the specified event type and symbol.">DXFeed::getLastEventPromise()</a> method.</p>
<p>The promise is cancelled when the the underlying <a class="el" href="../../d9/d00/struct_d_x_endpoint.html" title="Manages network connections to feed or publisher.">DXEndpoint</a> is <a class="el" href="../../d9/d00/struct_d_x_endpoint.html#a70b8f61781bf5991e1c0b77e4a13cb06">closed</a>. If the event is not available for any transient reason (no subscription, no connection to uplink, etc), then the resulting promise completes when the issue is resolved, which may involve an arbitrarily long wait. Use Promise::await() method to specify timeout while waiting for promise to complete. If the event is permanently not available (not supported), then the promise completes exceptionally with <a class="el" href="../../dd/d01/struct_java_exception.html" title="A wrapper over the interceptable Java exceptions thrown by the dxFeed Native Graal SDK.">JavaException</a> "IllegalArgumentException".</p>
<p>Use the following pattern of code to acquire multiple events (either for multiple symbols and/or multiple events) and wait with a single timeout for all of them:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> promises = <a class="code hl_function" href="#a9da30940a4c663a9b9a293d0692f240c">DXFeed::getInstance</a>()-&gt;<a class="code hl_function" href="#ab8349413be98d0cbf4fa2fde291b17da">getLastEventsPromises</a>&lt;<a class="code hl_class" href="../../de/d03/class_quote.html">Quote</a>&gt;({<span class="stringliteral">&quot;AAPL&amp;Q&quot;</span>, <span class="stringliteral">&quot;IBM&amp;Q&quot;</span>});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// combine the list of promises into one with Promises utility method and wait</span></div>
<div class="line"><a class="code hl_function" href="../../d7/d01/struct_promises.html#a9f8ce617edc6d6d5bbe945d48f86649a">Promises::allOf</a>(*promises)-&gt;awaitWithoutException(std::chrono::seconds(timeout));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// now iterate the promises to retrieve results</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; promise : *promises) {</div>
<div class="line">    doSomethingWith(promise-&gt;getResult()); <span class="comment">// InvalidArgumentException if result is nullptr</span></div>
<div class="line">}</div>
<div class="ttc" id="aclass_quote_html"><div class="ttname"><a href="../../de/d03/class_quote.html">Quote</a></div><div class="ttdoc">Quote event is a snapshot of the best bid and ask prices, and other fields that change with each quot...</div><div class="ttdef"><b>Definition</b> Quote.hpp:32</div></div>
<div class="ttc" id="astruct_d_x_feed_html_a9da30940a4c663a9b9a293d0692f240c"><div class="ttname"><a href="#a9da30940a4c663a9b9a293d0692f240c">DXFeed::getInstance</a></div><div class="ttdeci">static std::shared_ptr&lt; DXFeed &gt; getInstance()</div><div class="ttdoc">Returns a default application-wide singleton instance of feed.</div><div class="ttdef"><b>Definition</b> DXFeed.cpp:19</div></div>
<div class="ttc" id="astruct_d_x_feed_html_ab8349413be98d0cbf4fa2fde291b17da"><div class="ttname"><a href="#ab8349413be98d0cbf4fa2fde291b17da">DXFeed::getLastEventsPromises</a></div><div class="ttdeci">std::shared_ptr&lt; PromiseList&lt; E &gt; &gt; getLastEventsPromises(SymbolIt begin, SymbolIt end) const</div><div class="ttdoc">Requests the last events for the specified event type and a collection of symbols.</div><div class="ttdef"><b>Definition</b> DXFeed.hpp:478</div></div>
<div class="ttc" id="astruct_promises_html_a9f8ce617edc6d6d5bbe945d48f86649a"><div class="ttname"><a href="../../d7/d01/struct_promises.html#a9f8ce617edc6d6d5bbe945d48f86649a">Promises::allOf</a></div><div class="ttdeci">static std::shared_ptr&lt; Promise&lt; void &gt; &gt; allOf(Collection &amp;&amp;collection)</div><div class="ttdoc">Returns a new promise that completes when all promises from the given collection complete normally or...</div><div class="ttdef"><b>Definition</b> Promises.hpp:38</div></div>
</div><!-- fragment --><p>Note, that this method does not work when <a class="el" href="../../d9/d00/struct_d_x_endpoint.html" title="Manages network connections to feed or publisher.">DXEndpoint</a> was created with <a class="el" href="../../d9/d00/struct_d_x_endpoint.html#a4257e04caaa1ff898a60ece339e02810a08e8da2638e7a4a4dfb3d29ab5afb751">STREAM_FEED</a> role (promise completes exceptionally).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">E</td><td>The event type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">collection</td><td>The symbols collection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The list of promises for the result of the requests, one item in list per symbol. </dd></dl>

</div>
</div>
<a id="ab8349413be98d0cbf4fa2fde291b17da" name="ab8349413be98d0cbf4fa2fde291b17da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8349413be98d0cbf4fa2fde291b17da">&#9670;&#160;</a></span>getLastEventsPromises() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Derived&lt; <a class="el" href="../../dc/d00/struct_lasting_event.html">LastingEvent</a> &gt; E, typename SymbolIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="../../dd/d00/struct_promise_list.html">PromiseList</a>&lt; E &gt; &gt; DXFeed::getLastEventsPromises </td>
          <td>(</td>
          <td class="paramtype">SymbolIt</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SymbolIt</td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Requests the last events for the specified event type and a collection of symbols. </p>
<p>This method works only for event types that implement <a class="el" href="../../dc/d00/struct_lasting_event.html" title="Represents up-to-date information about some condition or state of an external entity that updates in...">LastingEvent</a> marker "interface". This method requests the data from the the uplink data provider, creates new events of the specified evet type, and completes the resulting promises with these events.</p>
<p>This is a bulk version of <a class="el" href="#ac055a7b46d8ba6cb0cf9a3ffb7c99187" title="Requests the last event for the specified event type and symbol.">DXFeed::getLastEventPromise()</a> method.</p>
<p>The promise is cancelled when the the underlying <a class="el" href="../../d9/d00/struct_d_x_endpoint.html" title="Manages network connections to feed or publisher.">DXEndpoint</a> is <a class="el" href="../../d9/d00/struct_d_x_endpoint.html#a70b8f61781bf5991e1c0b77e4a13cb06">closed</a>. If the event is not available for any transient reason (no subscription, no connection to uplink, etc), then the resulting promise completes when the issue is resolved, which may involve an arbitrarily long wait. Use Promise::await() method to specify timeout while waiting for promise to complete. If the event is permanently not available (not supported), then the promise completes exceptionally with <a class="el" href="../../dd/d01/struct_java_exception.html" title="A wrapper over the interceptable Java exceptions thrown by the dxFeed Native Graal SDK.">JavaException</a> "IllegalArgumentException".</p>
<p>Use the following pattern of code to acquire multiple events (either for multiple symbols and/or multiple events) and wait with a single timeout for all of them:</p>
<div class="fragment"><div class="line">std::vector&lt;dxfcpp::SymbolWrapper&gt; symbols{<span class="stringliteral">&quot;AAPL&amp;Q&quot;</span>, <span class="stringliteral">&quot;IBM&amp;Q&quot;</span>};</div>
<div class="line"><span class="keyword">auto</span> promises = <a class="code hl_function" href="#a9da30940a4c663a9b9a293d0692f240c">DXFeed::getInstance</a>()-&gt;<a class="code hl_function" href="#ab8349413be98d0cbf4fa2fde291b17da">getLastEventsPromises</a>&lt;<a class="code hl_class" href="../../de/d03/class_quote.html">Quote</a>&gt;(symbols.begin(), symbols.end());</div>
<div class="line"> </div>
<div class="line"><span class="comment">// combine the list of promises into one with Promises utility method and wait</span></div>
<div class="line"><a class="code hl_function" href="../../d7/d01/struct_promises.html#a9f8ce617edc6d6d5bbe945d48f86649a">Promises::allOf</a>(*promises)-&gt;awaitWithoutException(std::chrono::seconds(timeout));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// now iterate the promises to retrieve results</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; promise : *promises) {</div>
<div class="line">    doSomethingWith(promise-&gt;getResult()); <span class="comment">// InvalidArgumentException if result is nullptr</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Note, that this method does not work when <a class="el" href="../../d9/d00/struct_d_x_endpoint.html" title="Manages network connections to feed or publisher.">DXEndpoint</a> was created with <a class="el" href="../../d9/d00/struct_d_x_endpoint.html#a4257e04caaa1ff898a60ece339e02810a08e8da2638e7a4a4dfb3d29ab5afb751">STREAM_FEED</a> role (promise completes exceptionally).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">E</td><td>The event type. </td></tr>
    <tr><td class="paramname">SymbolIt</td><td>The symbols collection's iterator type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>The beginning of the collection of symbols (<a class="el" href="../../d1/d01/struct_symbol_wrapper.html" title="A helper wrapper class needed to pass heterogeneous symbols using a container and convert them to int...">SymbolWrapper</a>). </td></tr>
    <tr><td class="paramname">end</td><td>The end of the collection of symbols (<a class="el" href="../../d1/d01/struct_symbol_wrapper.html" title="A helper wrapper class needed to pass heterogeneous symbols using a container and convert them to int...">SymbolWrapper</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The list of promises for the result of the requests, one item in list per symbol. </dd></dl>

</div>
</div>
<a id="a6d1221d5316f92a42744fe619df4130c" name="a6d1221d5316f92a42744fe619df4130c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d1221d5316f92a42744fe619df4130c">&#9670;&#160;</a></span>getLastEventsPromises() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Derived&lt; <a class="el" href="../../dc/d00/struct_lasting_event.html">LastingEvent</a> &gt; E, <a class="el" href="../../d0/d03/concept_convertible_to_symbol_wrapper_collection.html">ConvertibleToSymbolWrapperCollection</a> SymbolsCollection&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="../../dd/d00/struct_promise_list.html">PromiseList</a>&lt; E &gt; &gt; DXFeed::getLastEventsPromises </td>
          <td>(</td>
          <td class="paramtype">SymbolsCollection &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>collection</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Requests the last events for the specified event type and a collection of symbols. </p>
<p>This method works only for event types that implement <a class="el" href="../../dc/d00/struct_lasting_event.html" title="Represents up-to-date information about some condition or state of an external entity that updates in...">LastingEvent</a> marker "interface". This method requests the data from the the uplink data provider, creates new events of the specified evet type, and completes the resulting promises with these events.</p>
<p>This is a bulk version of <a class="el" href="#ac055a7b46d8ba6cb0cf9a3ffb7c99187" title="Requests the last event for the specified event type and symbol.">DXFeed::getLastEventPromise()</a> method.</p>
<p>The promise is cancelled when the the underlying <a class="el" href="../../d9/d00/struct_d_x_endpoint.html" title="Manages network connections to feed or publisher.">DXEndpoint</a> is <a class="el" href="../../d9/d00/struct_d_x_endpoint.html#a70b8f61781bf5991e1c0b77e4a13cb06">closed</a>. If the event is not available for any transient reason (no subscription, no connection to uplink, etc), then the resulting promise completes when the issue is resolved, which may involve an arbitrarily long wait. Use Promise::await() method to specify timeout while waiting for promise to complete. If the event is permanently not available (not supported), then the promise completes exceptionally with <a class="el" href="../../dd/d01/struct_java_exception.html" title="A wrapper over the interceptable Java exceptions thrown by the dxFeed Native Graal SDK.">JavaException</a> "IllegalArgumentException".</p>
<p>Use the following pattern of code to acquire multiple events (either for multiple symbols and/or multiple events) and wait with a single timeout for all of them:</p>
<div class="fragment"><div class="line">std::vector&lt;dxfcpp::SymbolWrapper&gt; symbols{<span class="stringliteral">&quot;AAPL&amp;Q&quot;</span>, <span class="stringliteral">&quot;IBM&amp;Q&quot;</span>};</div>
<div class="line"><span class="keyword">auto</span> promises = <a class="code hl_function" href="#a9da30940a4c663a9b9a293d0692f240c">DXFeed::getInstance</a>()-&gt;<a class="code hl_function" href="#ab8349413be98d0cbf4fa2fde291b17da">getLastEventsPromises</a>&lt;<a class="code hl_class" href="../../de/d03/class_quote.html">Quote</a>&gt;(symbols);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// combine the list of promises into one with Promises utility method and wait</span></div>
<div class="line"><a class="code hl_function" href="../../d7/d01/struct_promises.html#a9f8ce617edc6d6d5bbe945d48f86649a">Promises::allOf</a>(*promises)-&gt;awaitWithoutException(std::chrono::seconds(timeout));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// now iterate the promises to retrieve results</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; promise : *promises) {</div>
<div class="line">    doSomethingWith(promise-&gt;getResult()); <span class="comment">// InvalidArgumentException if result is nullptr</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Note, that this method does not work when <a class="el" href="../../d9/d00/struct_d_x_endpoint.html" title="Manages network connections to feed or publisher.">DXEndpoint</a> was created with <a class="el" href="../../d9/d00/struct_d_x_endpoint.html#a4257e04caaa1ff898a60ece339e02810a08e8da2638e7a4a4dfb3d29ab5afb751">STREAM_FEED</a> role (promise completes exceptionally).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">E</td><td>The event type. </td></tr>
    <tr><td class="paramname">SymbolsCollection</td><td>The symbols collection's type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">collection</td><td>The symbols collection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The list of promises for the result of the requests, one item in list per symbol. </dd></dl>

</div>
</div>
<a id="a531ffc7dd7616d22b35f69ec7feebd5a" name="a531ffc7dd7616d22b35f69ec7feebd5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a531ffc7dd7616d22b35f69ec7feebd5a">&#9670;&#160;</a></span>getTimeSeriesPromise()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Derived&lt; <a class="el" href="../../da/d03/struct_time_series_event.html">TimeSeriesEvent</a> &gt; E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="../../d5/d00/struct_promise.html">Promise</a>&lt; std::vector&lt; std::shared_ptr&lt; E &gt; &gt; &gt; &gt; DXFeed::getTimeSeriesPromise </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/d01/struct_symbol_wrapper.html">SymbolWrapper</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>symbol</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t</td>          <td class="paramname"><span class="paramname"><em>fromTime</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t</td>          <td class="paramname"><span class="paramname"><em>toTime</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Requests time series of events for the specified event type, symbol, and a range of time. </p>
<p>This method works only for event types that implement <a class="el" href="../../da/d03/struct_time_series_event.html" title="Represents time-series snapshots of some process that is evolving in time or actual events in some ex...">TimeSeriesEvent</a> "interface". This method requests the data from the uplink data provider, creates a list of events of the specified <code>eventType</code>, and completes the resulting promise with this container. The events are ordered by <a class="el" href="../../da/d03/struct_time_series_event.html#a9d2ae41520f33140a6e823ae650e216a">time</a> in the container.</p>
<p>This method is designed for retrieval of a snapshot only. Use TimeSeriesEventModel if you need a list of time-series events that updates in real time.</p>
<p>The range and depth of events that are available with this service is typically constrained by upstream data provider.</p>
<p>The promise is cancelled when the underlying <a class="el" href="../../d9/d00/struct_d_x_endpoint.html" title="Manages network connections to feed or publisher.">DXEndpoint</a> is <a class="el" href="../../d9/d00/struct_d_x_endpoint.html#a70b8f61781bf5991e1c0b77e4a13cb06">closed</a>.</p>
<p>If events are not available for any transient reason (no subscription, no connection to uplink, etc.), then the resulting promise completes when the issue is resolved, which may involve an arbitrarily long wait. Use EventsPromiseMixin::await() method to specify timeout while waiting for promise to complete. If events are permanently not available (not supported), then the promise completes exceptionally with <a class="el" href="../../dd/d01/struct_java_exception.html" title="A wrapper over the interceptable Java exceptions thrown by the dxFeed Native Graal SDK.">JavaException</a> "IllegalArgumentException".</p>
<p>Note, that this method does not work when <a class="el" href="../../d9/d00/struct_d_x_endpoint.html" title="Manages network connections to feed or publisher.">DXEndpoint</a> was created with <a class="el" href="../../d9/d00/struct_d_x_endpoint.html#a4257e04caaa1ff898a60ece339e02810a08e8da2638e7a4a4dfb3d29ab5afb751">STREAM_FEED</a> role (promise completes exceptionally).</p>
<p>This method does not accept an instance of <a class="el" href="../../dd/d01/class_time_series_subscription_symbol.html" title="Represents subscription to time-series of events.">TimeSeriesSubscriptionSymbol</a> as a <code>symbol</code>. The later class is designed for use with <a class="el" href="../../dc/d00/class_d_x_feed_subscription.html" title="Subscription for a set of symbols and event types.">DXFeedSubscription</a> and to observe time-series subscription in <a class="el" href="../../da/d00/struct_d_x_publisher.html" title="Provides API for publishing of events to local or remote DXFeed.">DXPublisher</a>.</p>
<h3>Event flags</h3>
<p>This method completes promise only when a consistent snapshot of time series has been received from the data feed. The <a class="el" href="../../da/d02/struct_indexed_event.html#a5bf54899ccd5dd4bd162ae64fbcc695b">eventFlags</a> property of the events in the resulting container is always zero.</p>
<p>Note, that the resulting container <em>should not</em> be used with <a class="el" href="../../da/d00/struct_d_x_publisher.html#ae6e8cb6b370ea60f1ad5cb80cea2df30" title="Publishes events to the corresponding feed.">DXPublisher::publishEvents()</a> method, because the latter expects events in a different order and with an appropriate flags set. See documentation on a specific event class for details on how they should be published.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">E</td><td>The type of event. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">symbol</td><td>The symbol. </td></tr>
    <tr><td class="paramname">fromTime</td><td>The time, inclusive, to request events from (see <a class="el" href="../../da/d03/struct_time_series_event.html#a9d2ae41520f33140a6e823ae650e216a" title="Returns timestamp of the event.">TimeSeriesEvent::getTime()</a>). </td></tr>
    <tr><td class="paramname">toTime</td><td>The time, inclusive, to request events to (see <a class="el" href="../../da/d03/struct_time_series_event.html#a9d2ae41520f33140a6e823ae650e216a" title="Returns timestamp of the event.">TimeSeriesEvent::getTime()</a>). Use <code>std::numeric_limits&lt;std::int64_t&gt;::max()</code> or <code>LLONG_MAX</code> macro to retrieve events without an upper limit on time. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The promise for the result of the request. </dd></dl>

</div>
</div>
<a id="ad32672c2b620909071feb3e1727ff7db" name="ad32672c2b620909071feb3e1727ff7db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad32672c2b620909071feb3e1727ff7db">&#9670;&#160;</a></span>toString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string DXFeed::toString </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a string representation of the current object. </p>
<dl class="section return"><dt>Returns</dt><dd>a string representation </dd></dl>

<p>Reimplemented from <a class="el" href="../../df/d01/struct_shared_entity.html#a318336a61c8ecc73fe78e0ee6f0a0027">SharedEntity</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d1/d00/struct_d_x_feed.html">DXFeed</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
